---

category:
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    name: string(255)

location:
  actAs: 
    Timestampable: true
    NestedSet:
      hasManyRoots: true
      rootColumnName: root_id
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    name: string(255)
    description: string
    is_requiringReservation: { type: boolean, notnull: true, default: false }
    is_visible: { type: boolean, notnull: true, default: true } # If the location is visible for every
                                                                # visitor not logged in.

locationReservation: # This table contains reservations of locations
  actAs: [Timestampable]
  columns:
    id: { type: integer, primary: true, autoincrement: true }
    title: string(255)
    description: string
    location_id: { type: integer, notnull: true }
    accessDate: date # By default it will be set to startDate
    accessTime: time # By default it will be set to startTime
    startDate: { type: date, notnull: true }
    startTime: { type: time, notnull: true }
    endDate: { type: date, notnull: true }
    endTime: { type: time, notnull: true }
    arranger_id: integer
    user_id: integer
    parentLocationReservation_id: { type: integer, default: null }
    status: { type: integer, default: 3 } # Status codes: 3 -> unread, 2 -> pending, 1 -> accepted, 0 -> not accepted
    usageType_id: integer
  relations:
    parentLocationReservation: { class: locationReservation, local: parentLocationReservation_id, foreign: id, onDelete: CASCADE, foreignAlias: childLocationReservations, owningSide: true }
    location: { local: location_id, foreign: id, onDelete: CASCADE, foreignAlias: reservations }
    arranger: { local: arranger_id, foreign: id, onDelete: CASCADE, foreignAlias: locationReservations }
    user: { class: sfGuardUser, local: user_id, foreign: id, foreignAlias: locationReservations, onDelete: CASCADE }

locationReservationRequirementBase: # Base table for all location reservation requirements, will not be created or used directly.
                                    # Sadly, child tables don't inherit relations
  actAs: [Timestampable]
  columns:
    locationReservation_id: { type: integer, notnull: true }
    other: string

requirementLightSound:
  inheritance:
    extends: locationReservationRequirementBase
    type: concrete
  columns:
    externalSoundTech: boolean
    externalLightTech: boolean
    externalBackline: boolean
    is_requiringSmoke: boolean
    numberOfCrewMembers: integer
    numberOfBandMembers: integer
    soundCheckDate: { type: date, notnull: true }
    soundCheckTime: { type: time, notnull: true }
    getInDate: { type: date, notnull: true }
    getInTime: { type: time, notnull: true }
  relations:
    locationReservation: { local: locationReservation_id, foreign: id, foreignType: one, onDelete: CASCADE }

requirementPhotography:
  inheritance:
    extends: locationReservationRequirementBase
    type: concrete
  columns:
    print: integer # 0 -> no print, 1 -> less than or equal to A3, 2 -> more than A3
    web: integer # 0 -> no web, 1 -> 800x600, 2 -> original
    analogue: integer # 0 -> no analogue, 1 -> color, 2 -> black/white
    meetAtDate: { type: date, notnull: true }
    meetAtTime: { type: time, notnull: true }
  relations:
    locationReservation: { local: locationReservation_id, foreign: id, foreignType: one, onDelete: CASCADE }

requirementCatering:
  inheritance:
    extends: locationReservationRequirementBase
    type: concrete
  columns:
    allergy: string
    numberOfEaters: { type: integer, notnull: true }
    servedAtDate: { type: date, notnull: true }
    servedAtTime: { type: time, notnull: true }
  relations:
    locationReservation: { local: locationReservation_id, foreign: id, foreignType: one, onDelete: CASCADE }

locationAccessory: # This table can be used to list what accomodations/items a location can provide
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    location_id: integer
    name: string(128)
  relations:
    location: {local: location_id, foreign: id, foreignAlias: accessories}

locationUser:
  columns:
    user_id: {type: integer, notnull: true}
    location_id: {type: integer, notnull: true}
  relations:
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: locations, onDelete: CASCADE}
    location: {local: location_id, foreign: id, foreignAlias: users, onDelete: CASCADE}
  indexes:
    user_location:
      fields: [user_id, location_id]
      type: unique

arranger:
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    name: string(255)
    description: string

arrangerUser:
  columns:
    user_id: {type: integer, notnull: true}
    arranger_id: {type: integer, notnull: true}
    is_arrangerUserAdmin: {type: boolean, notnull: true, default: false} # If this flag is set, a user can add other users to this arranger
  relations:
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: arrangers, onDelete: CASCADE}
    arranger: {local: arranger_id, foreign: id, foreignAlias: users, onDelete: CASCADE}
  indexes:
    user_arranger:
      fields: [user_id, arranger_id]
      type: unique

loginLog:
  columns:
    user_id: integer
    timestamp: timestamp
    ip: string(15)
    type: integer
  relations:
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: loginLog}
  indexes:
    users:
      fields: [user_id]

discussionCategory:
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    name: string(64)

discussion: # This table will be used for discussions about events,
            # eg. requirements, contracts. It will be possible to
            # assign categories (or topics) so that relevant parts
            # of the discussion will go interested parties.
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    event_id: integer
    user_id: integer
    # You can specify a discussion category, but it's not required.
    # Discussion category makes it easy for bokers to set up requirements for the event.
    discussionCategory_id: {type: integer, default: null}
    title: string(255)
    message: string
  relations:
    event: {local: event_id, foreign: id, foreignAlias: discussion}
    user: {class: sfGuardUser, local: user_id, foreign: id}
    discussionCategory: {local: discussionCategory_id, foreign: id, foreignAlias: discussion}

discussionUser: # This table will hold all participants in a discussion
  actAs: [Timestampable]
  columns:
    user_id: integer
    event_id: integer
    # Status can be eg. participant or observer
    status: {type: integer, default: 1}
  relations:
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: discussionUsers}
    event: {local: event_id, foreign: id, foreignAlias: discussionUsers}

calendar: # This table will hold calendar names and other data.
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      notnull: true
      autoincrement: true
    name: string(255)

festival: # This table will hold all festivals
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      notnull: true
      primary: true
      autoincrement: true
    title: { type: string(255), notnull: true }
    leadParagraph: string(800)
    description: string
    linkout: {type: string(255), notnull: false}
    startDate: date
    startTime: time
    endDate: date
    endTime: time
    customLocation: {type: string(255), notnull: false}
    location_id: integer
  relations:
    commonLocation: {class: location, local: location_id, foreign: id, foreignAlias: festivals}
    arrangers:
      class: arranger
      refClass: festivalArranger
      foreignAlias: festivals

festivalArranger: # This table will hold relations between festivals and arrangers
  columns:
    festival_id: {type: integer, primary: true}
    arranger_id: {type: integer, primary: true}
  relations:
    festival:
      onDelete: CASCADE
    arranger:
      onDelete: CASCADE

event: # This table will hold all events.
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      notnull: true
      primary: true
      autoincrement: true
    title: { type: string(255), notnull: true }
    leadParagraph: string(800)
    description: string
    linkout: {type: string(255), notnull: false}
    startDate: date
    startTime: time
    endDate: date
    endTime: time
    # If an event has been accepted by a user in locationUser, if the location_id is connected to a user
    is_accepted: {type: boolean, default: true}
    is_public: {type: boolean, default: false}
    customLocation: {type: string(255), notnull: false}
    location_id: integer # This will be used for locations that recur, instead of manually typing locations.
    arranger_id: {type: integer, notnull: true}
    user_id: {type: integer, notnull: true}
    festival_id: integer
  relations:
    arranger: {local: arranger_id, foreign: id, foreignAlias: events}
    recurringLocation: {class: location, local: location_id, foreign: id, foreignAlias: events}
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: events}
    categories: {class: category, refClass: eventCategory, foreignAlias: events}
    festival: {local: festival_id, foreign: id, foreignAlias: events}
  indexes:
    locations:
      fields: [location_id]
    arrangers:
      fields: [arranger_id]

eventCategory:
  columns:
    event_id: {type: integer, primary: true}
    category_id: {type: integer, primary: true}
  relations:
    event:
      onDelete: CASCADE
    category:
      onDelete: CASCADE
