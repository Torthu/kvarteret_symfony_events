---

category:
  options:
    orderBy: name ASC
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    name: string(255)

location:
# When using the nested set module, it's not possible to sort by any other field than the ones used by nested set
#  options:
#    orderBy: name ASC
  actAs: 
    Timestampable: true
    NestedSet:
      hasManyRoots: true
      rootColumnName: root_id
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    name: string(255)
    description: string
    is_requiringReservation: { type: boolean, notnull: true, default: false }
    is_visible: { type: boolean, notnull: true, default: true } # If the location is visible for every
                                                                # visitor not logged in.

locationAccessory: # This table can be used to list what accomodations/items a location can provide
  actAs: [Timestampable]
  options:
    orderBy: name ASC
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    location_id: integer
    name: string(128)
  relations:
    location: {local: location_id, foreign: id, foreignAlias: accessories}

locationUser:
  columns:
    user_id: {type: integer, notnull: true}
    location_id: {type: integer, notnull: true}
  relations:
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: locations, onDelete: CASCADE}
    location: {local: location_id, foreign: id, foreignAlias: users, onDelete: CASCADE}
  indexes:
    user_location:
      fields: [user_id, location_id]
      type: unique

arranger:
  actAs: [Timestampable]
  options:
    orderBy: name ASC
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    name: string(255)
    description: string

arrangerUser:
  columns:
    user_id: {type: integer, notnull: true}
    arranger_id: {type: integer, notnull: true}
    is_arrangerUserAdmin: {type: boolean, notnull: true} # If this flag is set, a user can add other users to this arranger
  relations:
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: arrangers, onDelete: CASCADE}
    arranger: {local: arranger_id, foreign: id, foreignAlias: users, onDelete: CASCADE}
  indexes:
    user_arranger:
      fields: [user_id, arranger_id]
      type: unique

loginLog:
  options:
    orderBy: timestamp DESC
  columns:
    user_id: integer
    timestamp: timestamp
    ip: string(15)
    type: integer
  relations:
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: loginLog}
  indexes:
    users:
      fields: [user_id]

discussionCategory:
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    name: string(64)

discussion: # This table will be used for discussions about events,
            # eg. requirements, contracts. It will be possible to
            # assign categories (or topics) so that relevant parts
            # of the discussion will go interested parties.
  actAs: [Timestampable]
  options:
    orderBy: created_at ASC
  columns:
    id:
      type: integer
      primary: true
      autoincrement: true
    event_id: integer
    user_id: integer
    # You can specify a discussion category, but it's not required.
    # Discussion category makes it easy for bokers to set up requirements for the event.
    discussionCategory_id: {type: integer, default: null}
    title: string(255)
    message: string
  relations:
    event: {local: event_id, foreign: id, foreignAlias: discussion}
    user: {class: sfGuardUser, local: user_id, foreign: id}
    discussionCategory: {local: discussionCategory_id, foreign: id, foreignAlias: discussion}

discussionUser: # This table will hold all participants in a discussion
  actAs: [Timestampable]
  columns:
    user_id: integer
    event_id: integer
    # Status can be eg. participant or observer
    status: {type: integer, default: 1}
  relations:
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: discussionUsers}
    event: {local: event_id, foreign: id, foreignAlias: discussionUsers}

calendar: # This table will hold calendar names and other data.
  actAs: [Timestampable]
  columns:
    id:
      type: integer
      primary: true
      notnull: true
      autoincrement: true
    name: string(255)


event: # This table will hold all events.
  actAs: [Timestampable]
  options:
    orderBy: [startDate ASC, startTime ASC, title ASC]
  columns:
    id:
      type: integer
      notnull: true
      primary: true
      autoincrement: true
#    parentEvent_id: # parentEvent allows you to organize a festival and connect events to the festival.
#      type: integer
#      notnull: false
#      default: null
    title: { type: string(255), notnull: true }
    leadParagraph: string(800)
    description: string
    linkout: {type: string(255), notnull: false}
    startDate: date
    startTime: time
    endDate: date
    endTime: time
    # If an event has been accepted by a user in locationUser, if the location_id is connected to a user
    is_accepted: {type: boolean, default: true}
    is_public: {type: boolean, default: false}
    customLocation: {type: string(255), notnull: false}
    location_id: integer # This will be used for locations that recur, instead of manually typing locations.
    category_id: {type: integer, notnull: true}
    arranger_id: {type: integer, notnull: true}
    user_id: {type: integer, notnull: true}
  relations:
    arranger: {local: arranger_id, foreign: id, foreignAlias: events}
    recurringLocation: {class: location, local: location_id, foreign: id, foreignAlias: events}
    category: {local: category_id, foreign: id, foreignAlias: events}
    user: {class: sfGuardUser, local: user_id, foreign: id, foreignAlias: events}
#    parentEvent: {class: event, local: parentEvent_id, foreign: id, foreignAlias: childEvents}
  indexes:
    locations:
      fields: [location_id]
    arrangers:
      fields: [arranger_id]
    categories:
      fields: [category_id]
